use std::future::Future;

use crate::entry::context_switch::{self, CpuContext, Fault, CURRENT_CONTEXT};
use crate::prelude::*;
use crate::process::{ThreadRef, ThreadStatus};
use crate::util::log::{self, LevelFilter};

pub fn main_loop(
    current: ThreadRef,
    init_cpu_state: CpuContext,
) -> impl Future<Output = ()> + Send {
    // FIXME: this is only a temp solution; we should not mark the entire task Send.
    unsafe { mark_send::mark_send(__main_loop(current, init_cpu_state)) }
}

async fn __main_loop(current: ThreadRef, init_cpu_state: CpuContext) {
    unsafe {
        crate::process::current::set(current.clone());
    }
    CURRENT_CONTEXT.with(|context| {
        *context.borrow_mut() = init_cpu_state;
    });

    let thread_id = current.tid();
    let task_id = async_rt::task::current::get().tid().0;
    debug!("Thread #{} is executed as task #{}", thread_id, task_id);

    current.start();

    static YIELD_INTERVAL: u64 = 64; // same as DEFAULT_BUDGET
    let mut rounds: u64 = 0;

    loop {
        crate::signal::deliver_signal().await;

        crate::process::handle_force_stop().await;

        crate::process::handle_force_exit().await;

        if current.status() == ThreadStatus::Exited {
            break;
        }

        // If app check system info in a user level spin lock, the whole system would hung
        // workaround this issue, the final solution should update the scheduler
        rounds += 1;
        if rounds % YIELD_INTERVAL == 0 {
            async_rt::scheduler::yield_now().await;
        }

        // Continue the execution in the user space
        let fault = unsafe { context_switch::switch_to_user() };

        // Start a new round of log messages. We will set the description for
        // this round later when we have extracted more info from the fault.
        log::next_round(None);

        handle_fault(fault).await;
    }
}

async fn handle_fault(fault: Fault) {
    let res = match &fault {
        Fault::Syscall => super::syscall::handle_syscall().await,
        Fault::Exception(exception) => super::exception::handle_exception(exception).await,
        Fault::Interrupt => super::interrupt::handle_interrupt().await,
    };

    if let Err(e) = res {
        let should_log_err = |errno| {
            // If the log level requires every detail, don't ignore any error
            if log::max_level() == LevelFilter::Trace {
                return true;
            }

            // All other log levels require errors to be outputed. But
            // some errnos are usually benign and may occur in a very high
            // frequency. So we want to ignore them to keep noises at a
            // minimum level in the log.
            //
            // TODO: use a smarter, frequency-based strategy to decide whether
            // to suppress error messages.
            match errno {
                EAGAIN | ETIMEDOUT => false,
                _ => true,
            }
        };
        if should_log_err(e.errno()) {
            error!("Error = {}", e.backtrace());
        }
    }
}

pub mod mark_send {
    //! Mark an arbitrary future with Send trait.

    use std::future::Future;
    use std::pin::Pin;
    use std::task::{Context, Poll};

    /// Wrap a future with a new future that implements Send.
    ///
    /// Sometimes, a future that is automatically generated by the Rust compiler
    /// does not implement Send. But we know that the future is safe to implement
    /// Send. For situation like this, it is convenient to use this function to
    /// convert a future to a new Send-version.
    pub unsafe fn mark_send<F: Future>(f: F) -> SendFuture<F> {
        SendFuture::wrap(f)
    }

    pub struct SendFuture<F: Future> {
        inner: F,
    }

    impl<F: Future> SendFuture<F> {
        pub unsafe fn wrap(inner: F) -> Self {
            Self { inner }
        }
    }

    impl<F: Future> Future for SendFuture<F> {
        type Output = F::Output;

        fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
            unsafe { self.map_unchecked_mut(|self_| &mut self_.inner).poll(cx) }
        }
    }

    unsafe impl<F: Future> Send for SendFuture<F> {}
}
